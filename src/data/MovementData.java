package data;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class MovementData {
	private String id;
	private List<SensorReading> sensorData;
	private int prevIndex;
	private int nextIndex;

	/** Constructor with file name generated by hardware **/
	public MovementData(String fileName) {
		this.sensorData = buildMovementData(fileName);
		this.nextIndex = 0;
		this.prevIndex = -1;
	}

	/** Read data from sample file generated by hardware **/
	private List<SensorReading> buildMovementData(String fileName) {
		List<SensorReading> store = new ArrayList<SensorReading>();		

		// read from a file
		Scanner sc;
		try {
			sc = new Scanner(new File(fileName));
			// The first line is ID of data set
			if(sc.hasNextLine()) {
				setId(sc.nextLine());
			}
			while (sc.hasNextLine()) {
				String sCurrentLine = sc.nextLine();
				List<Integer> tempArray = new ArrayList<Integer>();
				String[] sr = sCurrentLine.split(",");
				for(int i=0; i<sr.length; i++) {
					int num = Integer.MIN_VALUE;
					try {
						num = Integer.parseInt(sr[i]);
					} catch(NumberFormatException nfe) {
						// if num is not integer, skip the current line
						break;
					}
					tempArray.add(num);
				}			
				if(tempArray.size() == sr.length) {
					SensorReading tempReading = new SensorReading(tempArray);
					store.add(tempReading);
				}
			}
			sc.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} 
		return store;	
	}


	/** Check if every element in sensorData is a valid SensorReading **/
	public boolean validate() {
		for(int i=0; i<sensorData.size(); i++) {
			if(!sensorData.get(i).isValid()) {
				return false;
			}
		}
		return true;
	}
	
	/** Returns true if there is a next SensorReading in the data set.
	 * @return true if and only if the data set has next SensorReading, otherwise false. */
	public boolean hasNext() {
		if(nextIndex < numOfSensorReading()) {
			return true;
		} else {
			return false;
		}
	}

	/** Returns true if there is a previous SensorReading in the data set.
	 * @return true if and only if the data set has previous SensorReading, otherwise false. */
	public boolean hasPrevious() {
		if(prevIndex > -1) {
			return true;
		} else {
			return false;
		}
	}
	
	/** Gets next SensorReading 
	 * @return next SensorReading if available, otherwise null*/
	public SensorReading getNext() {
		if(nextIndex < numOfSensorReading()) {
			SensorReading next = sensorData.get(nextIndex);
			prevIndex = nextIndex;
			nextIndex++;
			return next;
		} else {
			return null;
		}
	}

	/** Get previous SensorReading
	 * @return previous SensorReading if available, otherwise null */
	public SensorReading getPrevious() {
		if(prevIndex > -1) {
			SensorReading previous = sensorData.get(prevIndex);
			nextIndex = prevIndex;
			prevIndex--;
			return previous;
		} else {
			return null;
		}
	}

	public List<SensorReading> getSensorData() {
		return sensorData;
	}

	public void setSensorData(List<SensorReading> sensorData) {
		this.sensorData = sensorData;
	}

	private int numOfSensorReading() {
		return sensorData.size();		
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}
}
